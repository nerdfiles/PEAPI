// Generated by CoffeeScript 1.11.1

/*
@fileOverview ./src/management/__guide__.coffee
@description
Guide Interface treats a CLI state.
 */

(function() {
  var Guide, QueryManager, _, __reporter__, async, colors, crypto, defer, enabled, prep_request, prep_setup, request,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  defer = require('promise-defer');

  async = require('async');

  _ = require('lodash');

  crypto = require('crypto');

  request = require('request');

  QueryManager = require('./qm');

  colors = require('colors');

  enabled = true;


  /*
  @jsdoc
  @name prep_setup
  @inner
  @description
  Setup involves escalated rights and probably some statefulness.
   */

  prep_setup = function() {
    var g, qm;
    g = defer();
    qm = new QueryManager;
    g.resolve(true);
    qm.add_file('~/.bashrc').then(function(file_contents) {
      return console.log(file_contents);
    });
    return g.promise;
  };


  /*
  @jsdoc
  @name prep_request
  @inner
  @description
  Encrypt our file after having finally opened it.
   */

  prep_request = function(file) {
    var e, g, out, qm;
    g = defer();
    out = null;
    qm = new QueryManager;
    try {
      qm.add_file(file).then(function(file_contents) {
        var qs;
        out = crypto.createHash('sha256').update(file_contents).digest('base64');
        qs = {
          d: out
        };
        return g.resolve(qs);
      });
    } catch (error1) {
      e = error1;
      g.reject(e);
    }
    return g.promise;
  };


  /*
  @inner
  @name __reporter__
  @description
  A place to color in the guide book.
   */

  __reporter__ = function(doc, state) {
    var __doc__, __finalized__, __success__, __view__;
    if (/failed/.test(state) === true) {
      return;
    }
    __view__ = doc && doc.body;
    __success__ = (JSON.parse(__view__)).reason.rainbow;
    __finalized__ = 'task completed'.gray;
    __doc__ = __view__ ? __success__ : __finalized__;
    return console.log(__doc__);
  };


  /*
  @name Guide
  @class
  @description
  First guide book for PEAPI.
   */

  Guide = (function() {

    /*
    @name constructor
    @description
    Guide book constructor.
    @param cli {object} a Dict containing an input state from the user.
     */
    function Guide(cli) {
      var F, K, __file_mapper__, __stub__, d, methods;
      this.cli = cli;
      this.status = bind(this.status, this);
      this.setup = bind(this.setup, this);
      this.register = bind(this.register, this);
      if (!enabled) {
        return console.log('Guide: Disabled');
      }
      d = defer();
      if (!enabled) {
        d.reject(enabled);
      }
      if (enabled) {
        d.resolve(enabled);
      }
      this.config = this.cli.initConfig;
      F = _.filter(this.config, function(o, k) {
        if (_.isString(o)) {
          return o;
        }
      });
      K = _.filter(_.map(this.config, function(o, k) {
        if (o === true) {
          return k;
        }
      }));
      __file_mapper__ = _.map(K, (function(_this) {
        return function(methodName) {
          return function() {
            return _this[methodName](F, __reporter__);
          };
        };
      })(this));
      __stub__ = _.map(K, (function(_this) {
        return function(methodName) {
          return function() {
            return _this[methodName](__reporter__);
          };
        };
      })(this));
      if (!_.isEmpty(F)) {
        methods = __file_mapper__;
      } else {
        methods = __stub__;
      }
      async.series(methods, function() {
        return console.log(K.join('').rainbow + ' completed');
      });
      d.promise;
    }


    /*
    @method op
    @description
    API to proofofexistence.com.
     */

    Guide.prototype.op = function(m, file) {
      var d, method, url;
      d = defer();
      url = 'https://www.proofofexistence.com/api/v1/';
      method = url + m;
      prep_request(file).then(function(o) {
        return request({
          method: 'post',
          url: method,
          rejectUnauthorized: false,
          qs: o
        }, function(error, response, body) {
          if (error) {
            d.reject(error);
            return;
          }
          d.resolve(response);
        });
      });
      return d.promise;
    };


    /*
    @method register
    @cite https://proofofexistence.com/developers: used to register a new
    document's SHA256 digest. Returns a payment address where you need to send
    the bitcoins to have the document certified in the blockchain, and the
    amount of bitcoins you need to send expressed in satoshis
    (100000000 satoshis = 1 BTC).
    @param filename {string} a file from the local system to be computed for its
    SHA256 checksum digest and then registered to return a BTC address for payment.
    @param callback {function} a callback function
     */

    Guide.prototype.register = function(filename, callback) {
      return this.op("register", filename).then(function(data) {
        return callback(data, 'register finished');
      }, function() {
        return callback(null, 'register failed');
      });
    };


    /*
    @method setup
    @param callback {function} a callback function
     */

    Guide.prototype.setup = function(callback) {

      /*
      @method setup
       */
      prep_setup().then(function() {
        return callback(null, 'setup finished');
      });
    };


    /*
    @method status
    @cite https://proofofexistence.com/developers: receives a digest and returns
    the status of that document. If the status is `pending`, you'll also get the
    payment address and price to confirm the document in the blockchain.
    @param filename {string} a file from the local system to be computed for its SHA256
    checksum digest.
    @param callback {function} a callback function
     */

    Guide.prototype.status = function(filename, callback) {
      return this.op("status", filename).then(function(data) {
        return callback(data, 'status check finished');
      }, function() {
        return callback(null, 'status check failed');
      });
    };

    return Guide;

  })();

  module.exports = Guide;

}).call(this);
